// import React from 'react'
// import * as THREE from 'three'
// import { useState, useMemo, useRef, useEffect } from 'react'
// import { Canvas, useFrame, extend } from '@react-three/fiber'
// import { OrbitControls, Environment } from '@react-three/drei'
// import { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer.js'

// // -----------------------------------------------------------------------------
// // 1. THE SIMULATION SHADER (Physics Logic)
// // -----------------------------------------------------------------------------
// // This runs for every PIXEL in the data texture.
// // Each pixel represents one particle's position.
// const simulationVertexShader = `
//   uniform float uTime;
  
//   // GLSL Noise (Standard Simplex)
//   vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
//   vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
//   vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
//   vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
//   float snoise(vec3 v) {
//       const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
//       const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
//       vec3 i  = floor(v + dot(v, C.yyy) );
//       vec3 x0 = v - i + dot(i, C.xxx) ;
//       vec3 g = step(x0.yzx, x0.xyz);
//       vec3 l = 1.0 - g;
//       vec3 i1 = min( g.xyz, l.zxy );
//       vec3 i2 = max( g.xyz, l.zxy );
//       vec3 x1 = x0 - i1 + C.xxx;
//       vec3 x2 = x0 - i2 + C.yyy;
//       vec3 x3 = x0 - D.yyy;
//       i = mod289(i);
//       vec4 p = permute( permute( permute( 
//                   i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
//               + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
//               + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
//       float n_ = 0.142857142857;
//       vec3  ns = n_ * D.wyz - D.xzx;
//       vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
//       vec4 x_ = floor(j * ns.z);
//       vec4 y_ = floor(j - 7.0 * x_ );
//       vec4 x = x_ *ns.x + ns.yyyy;
//       vec4 y = y_ *ns.x + ns.yyyy;
//       vec4 h = 1.0 - abs(x) - abs(y);
//       vec4 b0 = vec4( x.xy, y.xy );
//       vec4 b1 = vec4( x.zw, y.zw );
//       vec4 s0 = floor(b0)*2.0 + 1.0;
//       vec4 s1 = floor(b1)*2.0 + 1.0;
//       vec4 sh = -step(h, vec4(0.0));
//       vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
//       vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
//       vec3 p0 = vec3(a0.xy,h.x);
//       vec3 p1 = vec3(a0.zw,h.y);
//       vec3 p2 = vec3(a1.xy,h.z);
//       vec3 p3 = vec3(a1.zw,h.w);
//       vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
//       p0 *= norm.x;
//       p1 *= norm.y;
//       p2 *= norm.z;
//       p3 *= norm.w;
//       vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
//       m = m * m;
//       return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
//                                   dot(p2,x2), dot(p3,x3) ) );
//   }

//   void main() {
//     // Current coordinate of the particle pixel (e.g. 0.5, 0.5)
//     vec2 uv = gl_FragCoord.xy / resolution.xy;
    
//     // Read the CURRENT position from the texture
//     // 'texturePosition' is auto-generated by GPUComputationRenderer
//     vec4 tmpPos = texture2D( texturePosition, uv );
//     vec3 position = tmpPos.xyz;

//     // PHYSICS LOGIC:
//     // Add Curl Noise to position
//     float frequency = 1.0;
//     float amplitude = 0.01;
    
//     // Simple logic: Move outwards based on noise + time
//     vec3 noise = vec3(
//         snoise(position * frequency + uTime * 0.5),
//         snoise(position * frequency + uTime * 0.5 + 100.0), // Offset for Y
//         snoise(position * frequency + uTime * 0.5 + 200.0)  // Offset for Z
//     );

//     // If particle gets too far, reset it? 
//     // For now, let's just make them wiggle and drift
//     position += noise * amplitude;

//     // Write new position to the output texture
//     gl_FragColor = vec4( position, 1.0 );
//   }
// `

// // -----------------------------------------------------------------------------
// // 2. THE RENDER SHADER (Visuals)
// // -----------------------------------------------------------------------------
// // This takes the position data and actually draws the dots on screen
// const renderVertexShader = `
//   uniform sampler2D uPositions; // The texture containing positions
//   uniform float uTime;
  
//   void main() {
//     // 1. Read position from texture
//     // 'position' here is actually the UV reference (0..1) we set up in geometry
//     // We use the xy coordinates of the geometry vertex to pick the right pixel from the texture
//     vec3 pos = texture2D(uPositions, position.xy).xyz;

//     // 2. Standard MVP Transform
//     vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
//     gl_Position = projectionMatrix * mvPosition;

//     // 3. Size Attenuation (Make distant particles smaller)
//     gl_PointSize = 3.0 * (1.0 / -mvPosition.z);
//   }
// `

// const renderFragmentShader = `
//   void main() {
//     // Make them circles
//     float dist = distance(gl_PointCoord, vec2(0.5));
//     if (dist > 0.5) discard;
    
//     gl_FragColor = vec4(0.0, 1.0, 0.8, 1.0); // Cyan color
//   }
// `

// // -----------------------------------------------------------------------------
// // 3. THE PARTICLES COMPONENT
// // -----------------------------------------------------------------------------
// function Particles() {
//   const size = 128 // Texture size: 128x128 = 16,384 particles
//   const count = size * size
  
//   // References
//   const gpuCompute = useRef()
//   const positionVariable = useRef()
//   const pointsRef = useRef()
  
//   // Initialize GPU Computation (Once)
//   const { gl } = useThree() // Access the WebGLRenderer
  
//   useMemo(() => {
//     // 1. Create the GPGPU Renderer
//     const gpu = new GPUComputationRenderer(size, size, gl)
    
//     // 2. Create Initial Data (A Sphere)
//     const dtPosition = gpu.createTexture()
//     const dataArr = dtPosition.image.data
    
//     for (let i = 0; i < dataArr.length; i += 4) {
//       // Random Point on Sphere Surface
//       // Math: r * sin(phi) * cos(theta)... standard spherical conversion
//       const r = 3.0; // Radius
//       const theta = Math.random() * Math.PI * 2
//       const phi = Math.acos(Math.random() * 2 - 1)
      
//       const x = r * Math.sin(phi) * Math.cos(theta)
//       const y = r * Math.sin(phi) * Math.sin(theta)
//       const z = r * Math.cos(phi)
      
//       dataArr[i] = x
//       dataArr[i + 1] = y
//       dataArr[i + 2] = z
//       dataArr[i + 3] = 1 // Alpha (unused)
//     }
    
//     // 3. Add Variable
//     const variable = gpu.addVariable('texturePosition', simulationVertexShader, dtPosition)
//     gpu.setVariableDependencies(variable, [variable])
    
//     // Add custom uniforms to simulation
//     variable.material.uniforms.uTime = { value: 0 }
    
//     // Check for errors
//     const error = gpu.init()
//     if (error !== null) console.error(error)
    
//     gpuCompute.current = gpu
//     positionVariable.current = variable
//   }, [gl])

//   // Create Geometry References
//   // Instead of passing x,y,z to the vertex shader, we pass "Reference UVs"
//   // So Vertex 0 knows to look at pixel (0,0). Vertex 1 looks at (0.01, 0).
//   const references = useMemo(() => {
//     const refs = new Float32Array(count * 3)
//     for (let i = 0; i < size; i++) {
//       for (let j = 0; j < size; j++) {
//         const k = (i * size + j) * 3
//         refs[k] = j / (size - 1)     // U
//         refs[k + 1] = i / (size - 1) // V
//         refs[k + 2] = 0 // Unused
//       }
//     }
//     return refs
//   }, [])

//   const uniforms = useMemo(() => ({
//     uPositions: { value: null },
//     uTime: { value: 0 }
//   }), [])

//   // The Loop
//   useFrame((state) => {
//     const time = state.clock.getElapsedTime()
    
//     // 1. Update Simulation Shader
//     const v = positionVariable.current
//     v.material.uniforms.uTime.value = time
    
//     // 2. Run GPGPU
//     gpuCompute.current.compute()
    
//     // 3. Update Render Shader
//     // Get the result texture from the simulation and pass it to the points material
//     pointsRef.current.material.uniforms.uPositions.value = 
//         gpuCompute.current.getCurrentRenderTarget(v).texture
//   })

//   return (
//     <points ref={pointsRef}>
//       <bufferGeometry>
//         <bufferAttribute
//           attach="attributes-position"
//           count={count}
//           array={references}
//           itemSize={3}
//         />
//       </bufferGeometry>
//       <shaderMaterial 
//         vertexShader={renderVertexShader}
//         fragmentShader={renderFragmentShader}
//         uniforms={uniforms}
//         transparent
//       />
//     </points>
//   )
// }

// // Helper to access `useThree` inside Canvas
// import { useThree } from '@react-three/fiber'

// export default function App() {
//   return (
//     <div style={{ width: '100vw', height: '100vh', background: '#000' }}>
//       <Canvas camera={{ position: [0, 0, 8] }}>
//         <OrbitControls />
//         <Particles />
//       </Canvas>
//     </div>
//   )
// }
import React from 'react'
import * as THREE from 'three'
import { useState, useMemo, useRef } from 'react'
import { Canvas, useFrame, useThree } from '@react-three/fiber'
import { OrbitControls, Environment, Text } from '@react-three/drei'
import { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer.js'

// -----------------------------------------------------------------------------
// 1. SIMULATION SHADER (The Physics Brain)
// -----------------------------------------------------------------------------
const simulationShader = `
  uniform float uTime;
  uniform float uHover; // 0 = Form Shape, 1 = Explode
  uniform sampler2D textureOrigin; // The "Memory" of where it started

  // --- SIMPLEX NOISE FUNCTION (Standard GLSL Copy-Paste) ---
  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
  vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
  float snoise(vec3 v) {
      const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
      const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
      vec3 i  = floor(v + dot(v, C.yyy) );
      vec3 x0 = v - i + dot(i, C.xxx) ;
      vec3 g = step(x0.yzx, x0.xyz);
      vec3 l = 1.0 - g;
      vec3 i1 = min( g.xyz, l.zxy );
      vec3 i2 = max( g.xyz, l.zxy );
      vec3 x1 = x0 - i1 + C.xxx;
      vec3 x2 = x0 - i2 + C.yyy;
      vec3 x3 = x0 - D.yyy;
      i = mod289(i);
      vec4 p = permute( permute( permute( 
                  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
              + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
              + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
      float n_ = 0.142857142857;
      vec3  ns = n_ * D.wyz - D.xzx;
      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
      vec4 x_ = floor(j * ns.z);
      vec4 y_ = floor(j - 7.0 * x_ );
      vec4 x = x_ *ns.x + ns.yyyy;
      vec4 y = y_ *ns.x + ns.yyyy;
      vec4 h = 1.0 - abs(x) - abs(y);
      vec4 b0 = vec4( x.xy, y.xy );
      vec4 b1 = vec4( x.zw, y.zw );
      vec4 s0 = floor(b0)*2.0 + 1.0;
      vec4 s1 = floor(b1)*2.0 + 1.0;
      vec4 sh = -step(h, vec4(0.0));
      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
      vec3 p0 = vec3(a0.xy,h.x);
      vec3 p1 = vec3(a0.zw,h.y);
      vec3 p2 = vec3(a1.xy,h.z);
      vec3 p3 = vec3(a1.zw,h.w);
      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
      p0 *= norm.x;
      p1 *= norm.y;
      p2 *= norm.z;
      p3 *= norm.w;
      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
      m = m * m;
      return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                  dot(p2,x2), dot(p3,x3) ) );
  }

  void main() {
    // 1. Get Coordinates
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    vec3 currentPos = texture2D( texturePosition, uv ).xyz;
    vec3 originalPos = texture2D( textureOrigin, uv ).xyz;

    // 2. Calculate Noise (The Explosion Force)
    float frequency = 0.5;
    vec3 noise = vec3(
        snoise(currentPos * frequency + uTime * 0.2),
        snoise(currentPos * frequency + uTime * 0.2 + 100.0),
        snoise(currentPos * frequency + uTime * 0.2 + 200.0)
    );

    // 3. THE PHYSICS LOGIC
    // Calculate direction back home
    vec3 direction = originalPos - currentPos;
    
    // If uHover is 1 (Explode), we push out with Noise.
    // If uHover is 0 (Return), we pull back with Direction.
    
    vec3 velocity = mix(direction * 0.1, noise * 0.2, uHover);
    
    // Update position
    gl_FragColor = vec4( currentPos + velocity, 1.0 );
  }
`

// -----------------------------------------------------------------------------
// 2. RENDER SHADER (Visuals)
// -----------------------------------------------------------------------------
const renderVertexShader = `
  uniform sampler2D uPositions;
  varying vec3 vPos;

  void main() {
    // Read position from GPGPU texture
    vec3 pos = texture2D(uPositions, position.xy).xyz;
    vPos = pos;

    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
    gl_Position = projectionMatrix * mvPosition;
    
    // Size attenuation (Bigger when close)
    gl_PointSize = 4.0 * (1.0 / -mvPosition.z);
  }
`

const renderFragmentShader = `
  varying vec3 vPos;
  void main() {
    // Circle shape
    float dist = distance(gl_PointCoord, vec2(0.5));
    if (dist > 0.5) discard;
    
    // Color based on position
    vec3 color = mix(vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 1.0), vPos.x * 0.2 + 0.5);
    gl_FragColor = vec4(color, 1.0);
  }
`

// -----------------------------------------------------------------------------
// 3. THE COMPONENT
// -----------------------------------------------------------------------------
function Particles() {
  const size = 128 // 128x128 = 16,384 particles
  const { gl } = useThree()
  
  // Hover State
  const [hovered, setHover] = useState(false)
  const hoverValue = useRef(0)

  // Memoize the GPGPU setup so it runs once
  const { gpu, positionVariable, points } = useMemo(() => {
    const gpu = new GPUComputationRenderer(size, size, gl)
    
    // A. Create Data Textures
    const dtPosition = gpu.createTexture()
    const dtOrigin = gpu.createTexture() // STATIC MEMORY
    
    const posArray = dtPosition.image.data
    const orgArray = dtOrigin.image.data

    for (let i = 0; i < posArray.length; i += 4) {
      // Sphere Math
      const r = 3;
      const theta = Math.random() * Math.PI * 2
      const phi = Math.acos(Math.random() * 2 - 1)
      const x = r * Math.sin(phi) * Math.cos(theta)
      const y = r * Math.sin(phi) * Math.sin(theta)
      const z = r * Math.cos(phi)

      // Fill BOTH textures with the same starting data
      posArray[i] = x; orgArray[i] = x;
      posArray[i+1] = y; orgArray[i+1] = y;
      posArray[i+2] = z; orgArray[i+2] = z;
      posArray[i+3] = 1; orgArray[i+3] = 1;
    }

    // B. Setup Variables
    const variable = gpu.addVariable('texturePosition', simulationShader, dtPosition)
    gpu.setVariableDependencies(variable, [variable])
    
    // IMPORTANT: Pass the Static Origin texture to the shader
    variable.material.uniforms.textureOrigin = { value: dtOrigin }
    variable.material.uniforms.uTime = { value: 0 }
    variable.material.uniforms.uHover = { value: 0 }

    gpu.init()

    // C. Create Geometry References (UVs)
    const geometry = new THREE.BufferGeometry()
    const positions = new Float32Array(size * size * 3)
    for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
            const k = (i * size + j) * 3
            positions[k] = j / (size - 1)
            positions[k+1] = i / (size - 1)
            positions[k+2] = 0
        }
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))

    return { gpu, positionVariable: variable, points: geometry }
  }, [gl])

  // D. The Loop
  useFrame((state, delta) => {
    // 1. Lerp the Hover Value (Smooth transition)
    hoverValue.current = THREE.MathUtils.lerp(hoverValue.current, hovered ? 1 : 0, 0.1)
    
    // 2. Update Simulation Uniforms
    positionVariable.material.uniforms.uTime.value = state.clock.elapsedTime
    positionVariable.material.uniforms.uHover.value = hoverValue.current
    
    // 3. Compute
    gpu.compute()
    
    // 4. Render
    // Get the fresh positions texture and pass it to the visual material
    const texture = gpu.getCurrentRenderTarget(positionVariable).texture
    materialRef.current.uniforms.uPositions.value = texture
  })

  const materialRef = useRef()

  return (
    // Interactive Mesh wrapper to catch mouse events
    <group 
        onPointerOver={() => setHover(true)} 
        onPointerOut={() => setHover(false)}
    >
        {/* Invisible Hit Box (Sphere) to trigger hover easily */}
        <mesh visible={false}>
            <sphereGeometry args={[3.5, 32, 32]} />
            <meshBasicMaterial />
        </mesh>

        {/* The Particles */}
        <points geometry={points}>
            <shaderMaterial 
                ref={materialRef}
                vertexShader={renderVertexShader}
                fragmentShader={renderFragmentShader}
                uniforms={{ uPositions: { value: null } }}
                transparent
                depthWrite={false}
                blending={THREE.AdditiveBlending}
            />
        </points>
    </group>
  )
}

// -----------------------------------------------------------------------------
// 4. THE APP
// -----------------------------------------------------------------------------
export default function App() {
  return (
    <div style={{ width: '100vw', height: '100vh', background: '#050505' }}>
      <Canvas camera={{ position: [0, 0, 8] }}>
        <color attach="background" args={['#050505']} />
        
        <Particles />
        
        <OrbitControls />
        <Environment preset="city" />
        
        <Text position={[0, -4, 0]} fontSize={0.5} color="#555">
            HOVER TO DISINTEGRATE
        </Text>
      </Canvas>
    </div>
  )
}