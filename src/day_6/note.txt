ğŸ¯ RAYCASTER â€” The Full Conceptual Breakdown

Raycasting is one of the most important concepts in 3D programming.
It allows you to:

detect which object the mouse is pointing at

detect clicks

read UVs

create interactions (hover, select, drag, etc)

build games, editors, painting tools, and UI systems

Letâ€™s go line by line in the section you asked about.

ğŸ§© PART 3 â€” RAYCASTER SETUP
const raycaster = new THREE.Raycaster();

âœ” What it does

Creates a raygun object.

A Raycaster shoots an invisible laser ray from:

the camera â†’

through the mouse position on the screen â†’

into 3D space â†’

and tells you which objects it hits.

âœ” Why it matters

This is the foundation of:

picking objects

hover effects

click detection

selecting 3D models

3D drawing/painting

physics interactions

const mouse = new THREE.Vector2();

âœ” What it does

Stores the mouse position in normalized device coordinates (NDC):

X is from -1 to +1

Y is from -1 to +1

You need NDC because WebGL works in NDC space.

âœ” Why it matters

Raycasting only understands normalized coordinates, not pixels.

let currentlyHovered = null;

âœ” What it does

Tracks which object is currently under the mouse.

âœ” Why it matters

Without this:

hover colors would flicker

youâ€™d reset colors every frame

performance would be bad

This variable creates a state machine:

hover enter

hover exit

hover stay

ğŸ§© PART 4 â€” MOUSE MOVE
window.addEventListener('mousemove', (event) => {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
});

âœ” Line-by-line explanation
1ï¸âƒ£ Get mouse pixel location

event.clientX = where mouse is in pixels (0 â†’ width)
event.clientY = where mouse is in pixels (0 â†’ height)

2ï¸âƒ£ Convert pixels to NDC
(event.clientX / window.innerWidth) â†’ 0 to 1
* 2 - 1 â†’ -1 to +1

3ï¸âƒ£ Invert Y

WebGLâ€™s Y axis is opposite of browser Y, so:

-(event.clientY / window.innerHeight) * 2 + 1

âœ” Why this matters

You cannot raycast with pixel coordinates.
You must convert them.

ğŸ§© PART 5 â€” CLICK EVENT
raycaster.setFromCamera(mouse, camera);

âœ” What it does

This is the moment the ray is created.

Takes the camera

Takes the mouse (in NDC)

Computes a 3D direction vector

Creates a ray in space

This ray is now ready to hit objects.

const intersects = raycaster.intersectObjects(objectsToTest);

âœ” What it does

Shoots the ray into the 3D world and checks collisions.

âœ” Returns

An array of intersections sorted from nearest â†’ farthest.

Example structure of intersects[0]:

{
  object: Mesh,
  distance: 2.4,
  point: Vector3,
  face: Face3,
  uv: Vector2,
}

âœ” Why this matters

This gives you the exact part of the mesh you hit:

exact 3D point

exact UV coordinate

exact mesh

exact triangle

const hit = intersects[0];

âœ” What it does

Takes the closest object the ray hit.

ğŸ¯ Logging useful info
console.log("Object:", hit.object.name);
console.log("3D Position:", hit.point);
console.log("UV Coordinates:", hit.uv);

Meaning:

hit.object â†’ which cube was clicked

hit.point â†’ world-space 3D coordinate

hit.uv â†’ texture coordinate (0 to 1)

This is used in:

3D painting

texture drawing

decals

mesh editing

shaders interacting with mouse

ğŸ¨ Change color on click
hit.object.material.color.set(0x00ff00);


Makes the clicked cube green.

â³ Reset color later, but only if not hovered
if (hit.object !== currentlyHovered) {
    hit.object.material.color.set(hit.object.userData.originalColor);
}


Prevents hover color (red) from turning back to white.

ğŸ§© PART 6 â€” HOVER LOGIC (THE MOST IMPORTANT PART)
ğŸ”„ Called 60 times per second
raycaster.setFromCamera(mouse, camera);


We update the ray every frame for hover detection.

const intersects = raycaster.intersectObjects(objectsToTest);


Shoot ray continuously while mouse moves.

ğŸŸ¥ If mouse is over an object
const newlyHovered = intersects[0].object;

ğŸš¨ HOVER ENTER EVENT (object changed)
if (currentlyHovered !== newlyHovered) {


Meaning:

mouse entered a new object

OR mouse moved from empty space â†’ object

Actions:

Reset old hover

Highlight new hover

Update state

ğŸš¨ HOVER EXIT EVENT
else if (currentlyHovered) {


Meaning:

No intersections now

But last frame there was

So mouse moved away from the object.

Action:

currentlyHovered.material.color.set(originalColor);
currentlyHovered = null;

ğŸ§  SUMMARY OF RAYCASTER FLOW
ğŸ“Œ 1. Mouse moves

â†’ Convert to -1 to +1 NDC
â†’ Update ray every frame

ğŸ“Œ 2. Shoot the ray
raycaster.setFromCamera(mouse, camera);

ğŸ“Œ 3. Check for hits
intersectObjects()

ğŸ“Œ 4. Determine

hover enter

hover exit

click

UV coordinate

exact triangle

exact world-space hit point

ğŸ“Œ 5. Change object color based on state

hover â†’ red

click â†’ green

reset â†’ original